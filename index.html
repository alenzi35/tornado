<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>LCC Tornado Probability Map (CONUS)</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #111;
  }

  canvas {
    display: block;
  }

  #tooltip {
    position: absolute;
    padding: 6px 10px;
    background: rgba(0,0,0,0.85);
    color: white;
    border-radius: 5px;
    pointer-events: none;
    display: none;
    font-family: sans-serif;
    font-size: 13px;
    white-space: nowrap;
  }

  #forecastInfo {
    position: absolute;
    top: 10px;
    left: 10px;
    padding: 8px 12px;
    background: rgba(0,0,0,0.7);
    color: white;
    font-family: sans-serif;
    font-size: 13px;
    border-radius: 6px;
    z-index: 10;
  }
</style>
</head>

<body>

<canvas id="mapCanvas"></canvas>
<div id="tooltip"></div>
<div id="forecastInfo">Loading forecast…</div>

<script>
const canvas = document.getElementById("mapCanvas");
const ctx = canvas.getContext("2d");
const tooltip = document.getElementById("tooltip");
const infoBox = document.getElementById("forecastInfo");

let scale = 1;
let offsetX = 0;
let offsetY = 0;
let dragging = false;
let lastX, lastY;

let cells = [];
let borders = [];

let minProb = Infinity;
let maxProb = -Infinity;

// --------------------------------
// Resize canvas
// --------------------------------
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// --------------------------------
// Load CONUS borders (Census cb_2024_us_state_5m LCC-projected JSON)
// --------------------------------
fetch("map/data/borders_lcc.json")
  .then(r => r.json())
  .then(data => {
    borders = data.features;
    fitView();
    draw();
  });

// --------------------------------
// Load masked CONUS tornado probability cells
// --------------------------------
fetch("map/data/tornado_prob_lcc_masked.json")
  .then(r => r.json())
  .then(data => {
    cells = data.features;

    // Compute min/max for normalization
    cells.forEach(c => {
      minProb = Math.min(minProb, c.prob);
      maxProb = Math.max(maxProb, c.prob);
    });

    // Update forecast info box
    const runDate = data.run_date || "??????";
    const runHour = data.run_hour || "??";
    const fcst = data.forecast || "F01";

    const validStart = (parseInt(runHour,10)+1)%24;
    const validEnd = (parseInt(runHour,10)+2)%24;

    function pad(n){return n.toString().padStart(2,"0");}

    infoBox.innerHTML =
      `<b>RAP Tornado Probability</b><br>
      Run: ${runDate} ${pad(runHour)}Z (${fcst})<br>
      Valid: ${pad(validStart)}:00–${pad(validEnd)}:00 UTC`;

    fitView();
    draw();
  });

// --------------------------------
// Normalize probability → 0..1
// --------------------------------
function normProb(p) {
  if (maxProb === minProb) return 0;
  return (p - minProb) / (maxProb - minProb);
}

// --------------------------------
// Probability → Color
// --------------------------------
function probToColor(p) {
  const t = normProb(p);
  let r, g, b;
  if (t < 0.5) {
    const k = t * 2;
    r = Math.floor(128 * k);
    g = 0;
    b = Math.floor(255 - 127 * k);
  } else {
    const k = (t - 0.5) * 2;
    r = Math.floor(128 + 127 * k);
    g = 0;
    b = Math.floor(128 - 128 * k);
  }
  return `rgba(${r},${g},${b},0.8)`;
}

// --------------------------------
// Fit view to CONUS cells + borders
// --------------------------------
function fitView() {
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;

  cells.forEach(c => {
    minX = Math.min(minX, c.x);
    maxX = Math.max(maxX, c.x + (c.dx||1));
    minY = Math.min(minY, c.y);
    maxY = Math.max(maxY, c.y + (c.dy||1));
  });

  borders.forEach(line => {
    line.forEach(([x,y]) => {
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);
    });
  });

  const rx = maxX - minX;
  const ry = maxY - minY;

  scale = Math.min(canvas.width / rx, canvas.height / ry) * 0.9;
  offsetX = canvas.width/2 - (minX + rx/2) * scale;
  offsetY = canvas.height/2 + (minY + ry/2) * scale;
}

// --------------------------------
// Draw map
// --------------------------------
function draw() {
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.setTransform(scale, 0, 0, -scale, offsetX, offsetY);

  // Draw cells
  cells.forEach(c => {
    ctx.fillStyle = probToColor(c.prob);
    const dx = c.dx || 1000;
    const dy = c.dy || 1000;
    ctx.fillRect(c.x, c.y, dx, dy);
  });

  // Draw borders
  ctx.strokeStyle = "white";
  ctx.lineWidth = 1/scale;

  ctx.beginPath();
  borders.forEach(line => {
    line.forEach(([x,y], i) => {
      if (i === 0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    });
  });
  ctx.stroke();
}

// --------------------------------
// Screen → LCC coords
// --------------------------------
function screenToLCC(px, py) {
  return { x: (px - offsetX) / scale, y: -(py - offsetY) / scale };
}

// --------------------------------
// Tooltip on hover
// --------------------------------
canvas.addEventListener("mousemove", e => {
  const { x, y } = screenToLCC(e.offsetX, e.offsetY);
  let hit = null;

  for (const c of cells) {
    const dx = c.dx || 1000;
    const dy = c.dy || 1000;
    if (x >= c.x && x <= c.x + dx && y >= c.y && y <= c.y + dy) {
      hit = c;
      break;
    }
  }

  if (hit) {
    tooltip.style.display = "block";
    tooltip.style.left = (e.pageX + 12) + "px";
    tooltip.style.top = (e.pageY + 12) + "px";
    tooltip.innerHTML = `Probability: ${(hit.prob*100).toFixed(4)}%`;
  } else {
    tooltip.style.display = "none";
  }
});

// --------------------------------
// Zoom
// --------------------------------
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const z = e.deltaY < 0 ? 1.15 : 0.87;
  const mx = e.offsetX;
  const my = e.offsetY;
  offsetX = mx - z*(mx - offsetX);
  offsetY = my - z*(my - offsetY);
  scale *= z;
  draw();
});

// --------------------------------
// Pan
// --------------------------------
canvas.addEventListener("mousedown", e => {
  dragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
});

window.addEventListener("mouseup", () => dragging = false);

window.addEventListener("mousemove", e => {
  if (!dragging) return;
  offsetX += e.clientX - lastX;
  offsetY += e.clientY - lastY;
  lastX = e.clientX;
  lastY = e.clientY;
  draw();
});
</script>

</body>
</html>
