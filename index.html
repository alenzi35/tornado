<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>LCC Tornado Probability Map</title>

<style>
  body { margin:0; overflow:hidden; background:#111; }
  canvas { display:block; }
  #tooltip {
    position:absolute; padding:6px 10px;
    background:rgba(0,0,0,0.85);
    color:white; border-radius:5px;
    pointer-events:none; display:none;
    font-family:sans-serif; font-size:13px; white-space:nowrap;
  }
  #forecastInfo {
    position:absolute; top:10px; left:10px;
    padding:8px 12px; background:rgba(0,0,0,0.7);
    color:white; font-family:sans-serif; font-size:13px;
    border-radius:6px; z-index:10;
  }
</style>
</head>

<body>
<canvas id="mapCanvas"></canvas>
<div id="tooltip"></div>
<div id="forecastInfo">Loading forecast…</div>

<script>
const canvas = document.getElementById("mapCanvas");
const ctx = canvas.getContext("2d");
const tooltip = document.getElementById("tooltip");
const infoBox = document.getElementById("forecastInfo");

let scale=1, offsetX=0, offsetY=0, dragging=false, lastX, lastY;
let cells=[], borders=[];
let minProb=Infinity, maxProb=-Infinity;

// ------------------ Resize ------------------
function resizeCanvas() { canvas.width=window.innerWidth; canvas.height=window.innerHeight; }
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// ------------------ Load borders ------------------
fetch("map/data/borders_lcc.json").then(r=>r.json()).then(data=>{ borders=data.features; fitView(); draw(); });

// ------------------ Load cells ------------------
fetch("map/data/tornado_prob_lcc.json").then(r=>r.json()).then(data=>{
  cells=data.features;
  cells.forEach(c=>{ minProb=Math.min(minProb,c.prob); maxProb=Math.max(maxProb,c.prob); });

  const runDate=data.run_date||"??????";
  const runHour=data.run_hour||"??";
  const fcst=data.forecast||"F01";
  const validStart=(parseInt(runHour,10)+1)%24;
  const validEnd=(parseInt(runHour,10)+2)%24;
  function pad(n){return n.toString().padStart(2,"0");}
  infoBox.innerHTML=`<b>RAP Tornado Probability</b><br>
    Run: ${runDate} ${pad(runHour)}Z (${fcst})<br>
    Valid: ${pad(validStart)}:00–${pad(validEnd)}:00 UTC`;
  fitView(); draw();
});

// ------------------ Normalize probability ------------------
function normProb(p){ return maxProb===minProb?0:(p-minProb)/(maxProb-minProb); }

// ------------------ Probability → Color ------------------
function probToColor(p){
  const t=normProb(p); let r,g,b;
  if(t<0.5){ const k=t*2; r=Math.floor(128*k); g=0; b=Math.floor(255-127*k);}
  else{ const k=(t-0.5)*2; r=Math.floor(128+127*k); g=0; b=Math.floor(128-128*k);}
  return `rgba(${r},${g},${b},0.8)`;
}

// ------------------ Fit view ------------------
function fitView(){
  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
  cells.forEach(c=>{ minX=Math.min(minX,c.x); maxX=Math.max(maxX,c.x+(c.dx||1)); minY=Math.min(minY,c.y); maxY=Math.max(maxY,c.y+(c.dy||1)); });
  borders.forEach(line=>{ line.forEach(([x,y])=>{ minX=Math.min(minX,x); maxX=Math.max(maxX,x); minY=Math.min(minY,y); maxY=Math.max(maxY,y); }); });
  const rx=maxX-minX, ry=maxY-minY;
  scale=Math.min(canvas.width/rx, canvas.height/ry)*0.9;
  offsetX=canvas.width/2-(minX+rx/2)*scale;
  offsetY=canvas.height/2+(minY+ry/2)*scale;
}

// ------------------ Draw ------------------
function draw(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.setTransform(scale,0,0,-scale,offsetX,offsetY);

  // Cells
  cells.forEach(c=>{
    ctx.fillStyle=probToColor(c.prob);
    const dx=c.dx||1000, dy=c.dy||1000;
    ctx.fillRect(c.x,c.y,dx,dy);
  });

  // Borders
  ctx.strokeStyle="white";
  ctx.lineWidth=1/scale;
  ctx.beginPath();
  borders.forEach(line=>{ line.forEach(([x,y],i)=>{ if(i===0)ctx.moveTo(x,y); else ctx.lineTo(x,y); }); });
  ctx.stroke();
}

// ------------------ Screen → LCC ------------------
function screenToLCC(px,py){ return {x:(px-offsetX)/scale, y:-(py-offsetY)/scale}; }

// ------------------ Hover tooltip ------------------
canvas.addEventListener("mousemove",e=>{
  const {x,y}=screenToLCC(e.offsetX,e.offsetY);
  let hit=null;
  for(const c of cells){ const dx=c.dx||1000, dy=c.dy||1000; if(x>=c.x&&x<=c.x+dx&&y>=c.y&&y<=c.y+dy){ hit=c; break; } }
  if(hit){ tooltip.style.display="block"; tooltip.style.left=(e.pageX+12)+"px"; tooltip.style.top=(e.pageY+12)+"px"; tooltip.innerHTML=`Probability: ${(hit.prob*100).toFixed(4)}%`; }
  else tooltip.style.display="none";
});

// ------------------ Zoom ------------------
canvas.addEventListener("wheel",e=>{
  e.preventDefault();
  const z=e.deltaY<0?1.15:0.87, mx=e.offsetX, my=e.offsetY;
  offsetX=mx-z*(mx-offsetX); offsetY=my-z*(my-offsetY); scale*=z; draw();
});

// ------------------ Pan ------------------
canvas.addEventListener("mousedown",e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; });
window.addEventListener("mouseup",()=>dragging=false);
window.addEventListener("mousemove",e=>{ if(!dragging)return; offsetX+=e.clientX-lastX; offsetY+=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY; draw(); });
</script>
</body>
</html>
