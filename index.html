<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>LCC Tornado Probability Map</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #111;
  }

  canvas {
    display: block;
  }

  #tooltip {
    position: absolute;
    padding: 6px 10px;
    background: rgba(0,0,0,0.85);
    color: white;
    border-radius: 5px;
    pointer-events: none;
    display: none;
    font-family: sans-serif;
    font-size: 13px;
    white-space: nowrap;
  }

  #forecastInfo {
    position: absolute;
    top: 10px;
    left: 10px;
    padding: 8px 12px;
    background: rgba(0,0,0,0.7);
    color: white;
    font-family: sans-serif;
    font-size: 13px;
    border-radius: 6px;
    z-index: 10;
  }
</style>
</head>

<body>

<canvas id="mapCanvas"></canvas>
<div id="tooltip"></div>
<div id="forecastInfo">Loading forecast…</div>

<script>
const canvas = document.getElementById("mapCanvas");
const ctx = canvas.getContext("2d");
const tooltip = document.getElementById("tooltip");
const infoBox = document.getElementById("forecastInfo");

let scale = 1;
let offsetX = 0;
let offsetY = 0;

let dragging = false;
let lastX, lastY;

let cells = [];
let borders = [];

let minProb = Infinity;
let maxProb = -Infinity;

// --------------------------------
// Resize
// --------------------------------
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  draw();
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// --------------------------------
// Load borders
// --------------------------------
fetch("map/data/borders_lcc.json")
  .then(r => r.json())
  .then(data => {
    borders = data.features;
    fitView();
    draw();
  });

// --------------------------------
// Load masked cells
// --------------------------------
fetch("map/data/tornado_prob_lcc_masked.json")
  .then(r => r.json())
  .then(data => {

    cells = data.features;

    minProb = Infinity;
    maxProb = -Infinity;

    cells.forEach(c => {
      minProb = Math.min(minProb, c.prob);
      maxProb = Math.max(maxProb, c.prob);
    });

    const runDate = data.run_date || "??????";
    const runHour = data.run_hour || "??";
    const fcst = data.forecast || "F01";

    const validStart = (parseInt(runHour,10)+1)%24;
    const validEnd = (parseInt(runHour,10)+2)%24;

    function pad(n){return n.toString().padStart(2,"0");}

    infoBox.innerHTML =
      `<b>RAP Tornado Probability</b><br>
      Run: ${runDate} ${pad(runHour)}Z (${fcst})<br>
      Valid: ${pad(validStart)}:00–${pad(validEnd)}:00 UTC`;

    fitView();
    draw();
  });

// --------------------------------
// Normalize probability
// --------------------------------
function normProb(p) {
  if (maxProb === minProb) return 0;
  return (p - minProb) / (maxProb - minProb);
}

// --------------------------------
// Probability color scale
// --------------------------------
function probToColor(p) {

  const t = normProb(p);

  let r,g,b;

  if (t < 0.5) {
    const k = t * 2;
    r = Math.floor(128*k);
    g = 0;
    b = Math.floor(255 - 127*k);
  } else {
    const k = (t-0.5)*2;
    r = Math.floor(128 + 127*k);
    g = 0;
    b = Math.floor(128 - 128*k);
  }

  return `rgba(${r},${g},${b},0.8)`;
}

// --------------------------------
// Fit view
// --------------------------------
function fitView() {

  if (cells.length === 0) return;

  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;

  cells.forEach(c => {
    minX=Math.min(minX,c.x);
    maxX=Math.max(maxX,c.x+c.dx);
    minY=Math.min(minY,c.y);
    maxY=Math.max(maxY,c.y+c.dy);
  });

  const rx=maxX-minX;
  const ry=maxY-minY;

  scale=Math.min(canvas.width/rx, canvas.height/ry)*0.9;

  offsetX=canvas.width/2-(minX+rx/2)*scale;
  offsetY=canvas.height/2+(minY+ry/2)*scale;
}

// --------------------------------
// Draw
// --------------------------------
function draw(){

  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.setTransform(scale,0,0,-scale,offsetX,offsetY);

  // CELLS
  cells.forEach(c=>{
    ctx.fillStyle=probToColor(c.prob);
    ctx.fillRect(c.x,c.y,c.dx,c.dy);
  });

  // BORDERS
  ctx.strokeStyle="white";
  ctx.lineWidth=1/scale;

  ctx.beginPath();

  borders.forEach(line=>{
    line.forEach(([x,y],i)=>{
      if(i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    });
  });

  ctx.stroke();
}

// --------------------------------
// Screen to LCC
// --------------------------------
function screenToLCC(px,py){
  return{
    x:(px-offsetX)/scale,
    y:-(py-offsetY)/scale
  };
}

// --------------------------------
// Tooltip
// --------------------------------
canvas.addEventListener("mousemove",e=>{

  const {x,y}=screenToLCC(e.offsetX,e.offsetY);

  let hit=null;

  for(const c of cells){
    if(x>=c.x && x<=c.x+c.dx &&
       y>=c.y && y<=c.y+c.dy){
       hit=c;
       break;
    }
  }

  if(hit){
    tooltip.style.display="block";
    tooltip.style.left=(e.pageX+12)+"px";
    tooltip.style.top=(e.pageY+12)+"px";
    tooltip.innerHTML=`Probability: ${(hit.prob*100).toFixed(4)}%`;
  }else{
    tooltip.style.display="none";
  }
});

// --------------------------------
// Zoom
// --------------------------------
canvas.addEventListener("wheel",e=>{
  e.preventDefault();
  const zoom=e.deltaY<0?1.15:0.87;
  const mx=e.offsetX;
  const my=e.offsetY;
  offsetX=mx-zoom*(mx-offsetX);
  offsetY=my-zoom*(my-offsetY);
  scale*=zoom;
  draw();
});

// --------------------------------
// Pan
// --------------------------------
canvas.addEventListener("mousedown",e=>{
  dragging=true;
  lastX=e.clientX;
  lastY=e.clientY;
});
window.addEventListener("mouseup",()=>dragging=false);
window.addEventListener("mousemove",e=>{
  if(!dragging) return;
  offsetX+=e.clientX-lastX;
  offsetY+=e.clientY-lastY;
  lastX=e.clientX;
  lastY=e.clientY;
  draw();
});
</script>

</body>
</html>
