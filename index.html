<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>LCC Tornado Probability Map</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #111;
  }

  canvas {
    display: block;
  }

  #tooltip {
    position: absolute;
    padding: 6px 10px;
    background: rgba(0,0,0,0.85);
    color: white;
    border-radius: 5px;
    pointer-events: none;
    display: none;
    font-family: sans-serif;
    font-size: 13px;
  }

  #forecastInfo {
    position: absolute;
    top: 10px;
    left: 10px;
    padding: 8px 12px;
    background: rgba(0,0,0,0.7);
    color: white;
    font-family: sans-serif;
    font-size: 13px;
    border-radius: 6px;
    z-index: 10;
  }
</style>
</head>

<body>

<canvas id="mapCanvas"></canvas>
<div id="tooltip"></div>
<div id="forecastInfo">Loading forecast…</div>

<script>
const canvas=document.getElementById("mapCanvas");
const ctx=canvas.getContext("2d");
const tooltip=document.getElementById("tooltip");
const infoBox=document.getElementById("forecastInfo");

let scale=1;
let offsetX=0;
let offsetY=0;

let dragging=false;
let lastX,lastY;

let cells=[];
let borders=[];


// --------------------------------
// Resize
// --------------------------------
function resizeCanvas(){
  canvas.width=window.innerWidth;
  canvas.height=window.innerHeight;
}
window.addEventListener("resize",resizeCanvas);
resizeCanvas();


// --------------------------------
// Load borders
// --------------------------------
fetch("map/data/borders_lcc.json")
.then(r=>r.json())
.then(data=>{
  borders=data.features;
  fitView();
  draw();
});


// --------------------------------
// Load cells
// --------------------------------
fetch("map/data/tornado_prob_lcc.json")
.then(r=>r.json())
.then(data=>{

  cells=data.features;

  const runDate=data.run_date;
  const runHour=parseInt(data.run_hour);
  const fcst=data.forecast;

  const validStart=(runHour+1)%24;
  const validEnd=(runHour+2)%24;

  function pad(n){return n.toString().padStart(2,"0");}

  infoBox.innerHTML=
    `Run: ${runDate} ${pad(runHour)}Z (${fcst})<br>
     Valid: ${pad(validStart)}:00–${pad(validEnd)}:00 UTC`;

  fitView();
  draw();
});


// --------------------------------
// Gradient scale
// --------------------------------
function probToColor(p){

  const maxP=0.01;
  let t=p/maxP;

  if(t<0)t=0;
  if(t>1)t=1;

  const stops=[
    {t:0.00,c:[255,255,224]},
    {t:0.25,c:[255,255,0]},
    {t:0.50,c:[255,165,0]},
    {t:0.75,c:[255,0,0]},
    {t:1.00,c:[255,0,255]}
  ];

  let i;
  for(i=0;i<stops.length-1;i++){
    if(t>=stops[i].t && t<=stops[i+1].t) break;
  }

  const s0=stops[i];
  const s1=stops[i+1];

  const k=(t-s0.t)/(s1.t-s0.t);

  const r=Math.round(s0.c[0]+k*(s1.c[0]-s0.c[0]));
  const g=Math.round(s0.c[1]+k*(s1.c[1]-s0.c[1]));
  const b=Math.round(s0.c[2]+k*(s1.c[2]-s0.c[2]));

  return `rgba(${r},${g},${b},0.85)`;
}


// --------------------------------
// Fit view
// --------------------------------
function fitView(){

  if(cells.length===0)return;

  let minX=Infinity,maxX=-Infinity;
  let minY=Infinity,maxY=-Infinity;

  cells.forEach(c=>{
    minX=Math.min(minX,c.x);
    maxX=Math.max(maxX,c.x+c.dx);
    minY=Math.min(minY,c.y);
    maxY=Math.max(maxY,c.y+c.dy);
  });

  borders.forEach(line=>{
    line.forEach(([x,y])=>{
      minX=Math.min(minX,x);
      maxX=Math.max(maxX,x);
      minY=Math.min(minY,y);
      maxY=Math.max(maxY,y);
    });
  });

  const rx=maxX-minX;
  const ry=maxY-minY;

  scale=Math.min(canvas.width/rx,canvas.height/ry)*0.9;

  offsetX=canvas.width/2-(minX+rx/2)*scale;
  offsetY=canvas.height/2+(minY+ry/2)*scale;
}


// --------------------------------
// Draw
// --------------------------------
function draw(){

  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.setTransform(scale,0,0,-scale,offsetX,offsetY);

  // cells
  cells.forEach(c=>{
    ctx.fillStyle=probToColor(c.prob);
    ctx.fillRect(c.x,c.y,c.dx,c.dy);
  });

  // SPC-style gray borders
  ctx.strokeStyle="#A9A9A9";
  ctx.lineWidth=1/scale;

  ctx.beginPath();

  borders.forEach(line=>{
    line.forEach(([x,y],i)=>{
      if(i===0)ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    });
  });

  ctx.stroke();
}


// --------------------------------
// Screen to LCC
// --------------------------------
function screenToLCC(px,py){
  return{
    x:(px-offsetX)/scale,
    y:-(py-offsetY)/scale
  };
}


// --------------------------------
// Tooltip
// --------------------------------
canvas.addEventListener("mousemove",e=>{

  const {x,y}=screenToLCC(e.offsetX,e.offsetY);

  let hit=null;

  for(const c of cells){
    if(x>=c.x && x<=c.x+c.dx && y>=c.y && y<=c.y+c.dy){
      hit=c;
      break;
    }
  }

  if(hit){
    tooltip.style.display="block";
    tooltip.style.left=(e.pageX+12)+"px";
    tooltip.style.top=(e.pageY+12)+"px";
    tooltip.innerHTML=`Probability: ${(hit.prob*100).toFixed(4)}%`;
  }
  else{
    tooltip.style.display="none";
  }
});


// --------------------------------
// Zoom
// --------------------------------
canvas.addEventListener("wheel",e=>{

  e.preventDefault();

  const z=e.deltaY<0?1.15:0.87;

  offsetX=e.offsetX-z*(e.offsetX-offsetX);
  offsetY=e.offsetY-z*(e.offsetY-offsetY);

  scale*=z;

  draw();
});


// --------------------------------
// Pan
// --------------------------------
canvas.addEventListener("mousedown",e=>{
  dragging=true;
  lastX=e.clientX;
  lastY=e.clientY;
});

window.addEventListener("mouseup",()=>dragging=false);

window.addEventListener("mousemove",e=>{

  if(!dragging)return;

  offsetX+=e.clientX-lastX;
  offsetY+=e.clientY-lastY;

  lastX=e.clientX;
  lastY=e.clientY;

  draw();
});

</script>

</body>
</html>
